{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"simple-python-boilerplate","text":"<p>A minimal Python boilerplate using the src/ layout, configured with Hatch as the build system.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>src/ layout \u2014 clean separation between source code and project root.</li> <li>Hatch \u2014 modern build backend and environment manager.</li> <li>pytest \u2014 testing framework with coverage support.</li> <li>Ruff \u2014 fast linting and formatting.</li> <li>mypy \u2014 strict static type checking.</li> <li>MkDocs + Material \u2014 documentation with auto-generated API reference.</li> </ul>"},{"location":"#quick-links","title":"Quick links","text":"Resource Description Getting Started Installation and local development API Reference Auto-generated from source docstrings"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>src/\n  simple_python_boilerplate/\n    __init__.py       # Package root\n    api.py            # HTTP/REST interface\n    cli.py            # CLI argument parsing\n    engine.py         # Core business logic\n    main.py           # Entry points\ntests/                # Test suite\ndocs/                 # Documentation source\npyproject.toml        # Project configuration (single source of truth)\n</code></pre>"},{"location":"guide/getting-started/","title":"Getting Started","text":"<p>This guide covers installing the project and working with the documentation locally.</p>"},{"location":"guide/getting-started/#prerequisites","title":"Prerequisites","text":"<ul> <li>Python 3.11 or later</li> <li>Hatch (recommended) or plain pip</li> </ul>"},{"location":"guide/getting-started/#installation","title":"Installation","text":""},{"location":"guide/getting-started/#with-pip-editable-install-docs-dependencies","title":"With pip (editable install + docs dependencies)","text":"<pre><code>python -m pip install -e \".[docs]\"\n</code></pre>"},{"location":"guide/getting-started/#with-hatch","title":"With Hatch","text":"<p>Hatch manages environments automatically \u2014 no manual install step needed. Just run any <code>hatch run docs:*</code> command and the environment is created on first use.</p>"},{"location":"guide/getting-started/#serving-docs-locally","title":"Serving docs locally","text":"pipHatch <pre><code>mkdocs serve\n</code></pre> <pre><code>hatch run docs:serve\n</code></pre> <p>Open http://127.0.0.1:8000 in your browser. Changes to Markdown files are picked up automatically via live-reload.</p>"},{"location":"guide/getting-started/#building-docs","title":"Building docs","text":"pipHatch <pre><code>mkdocs build --strict\n</code></pre> <pre><code>hatch run docs:build\n</code></pre> <p>The <code>--strict</code> flag treats warnings as errors, which is the same mode used by the CI/RTD build.</p>"},{"location":"guide/getting-started/#read-the-docs","title":"Read the Docs","text":"<p>This project is configured for Read the Docs via <code>.readthedocs.yaml</code>. RTD builds are triggered automatically on push and use the project's built-in versioning (tags and branches) \u2014 no additional tooling like <code>mike</code> or GitHub Pages is required.</p>"},{"location":"guide/getting-started/#troubleshooting","title":"Troubleshooting","text":"<p>API reference page is empty or errors</p> <p>If the API reference page shows errors or is blank:</p> <ol> <li> <p>Confirm the package is importable. The <code>mkdocstrings</code> plugin    needs to import your code. Make sure you have installed the project    in editable mode:</p> <pre><code>python -m pip install -e \".[docs]\"\n</code></pre> </li> <li> <p>Check that modules exist under <code>src/</code>. The <code>mkdocstrings</code>    handler is configured with <code>paths: [src]</code> in <code>mkdocs.yml</code>. API    directives like <code>simple_python_boilerplate.engine</code> expect the    module to be at <code>src/simple_python_boilerplate/engine.py</code>.</p> </li> <li> <p>Avoid top-level side effects. Modules rendered by <code>mkdocstrings</code>    are imported at build time. Guard any executable code behind    <code>if __name__ == \"__main__\":</code> to prevent unintended execution during    the docs build.</p> </li> </ol> <p>Clearing stale build artifacts</p> <p>If the site behaves unexpectedly after changes, delete the build output and rebuild:</p> <pre><code>rm -rf site/\nmkdocs build --strict\n</code></pre> <p>Or let Hatch handle it:</p> <pre><code>hatch run docs:build --clean\n</code></pre>"},{"location":"reference/","title":"API Reference","text":"<p>This section contains auto-generated documentation for the <code>simple_python_boilerplate</code> package, built directly from source code docstrings and type annotations using mkdocstrings.</p>"},{"location":"reference/#how-it-works","title":"How it works","text":"<p>The <code>module.name</code> directive in Markdown tells <code>mkdocstrings</code> to import the specified module and render its public API \u2014 classes, functions, type aliases, and their docstrings \u2014 into the documentation page.</p> <p>Because this project uses the src/ layout, the <code>mkdocstrings</code> handler is configured with <code>paths: [src]</code> in <code>mkdocs.yml</code> so that imports resolve correctly during the docs build.</p>"},{"location":"reference/#sections","title":"Sections","text":"Page Description API Public modules: engine, api, and cli"},{"location":"reference/#writing-good-docstrings","title":"Writing good docstrings","text":"<p>This project uses Google-style docstrings (enforced by Ruff's <code>D</code> rules). A well-documented function looks like:</p> <pre><code>def process_data(raw: str, *, validate: bool = True) -&gt; dict[str, Any]:\n    \"\"\"Process raw input data and return structured results.\n\n    Args:\n        raw: The raw input string to process.\n        validate: Whether to validate before processing.\n\n    Returns:\n        A dictionary containing the processed results.\n\n    Raises:\n        ValueError: If the input data is malformed.\n    \"\"\"\n</code></pre> <p>When you add or update docstrings in the source code, the API reference updates automatically on the next build.</p>"},{"location":"reference/api/","title":"API","text":"<p>Auto-generated from source docstrings and type annotations.</p>"},{"location":"reference/api/#engine","title":"Engine","text":"<p>Core business logic \u2014 version info, environment diagnostics, and data processing.</p>"},{"location":"reference/api/#simple_python_boilerplate.engine","title":"<code>engine</code>","text":"<p>Core business logic and processing engine.</p> <p>This module contains the core functionality of the application, independent of any interface (CLI, API, etc.). It should be interface-agnostic and focused purely on domain logic.</p> Typical contents <ul> <li>Data processing functions</li> <li>Business rule implementations</li> <li>Core algorithms</li> <li>State management</li> <li>Environment diagnostics</li> </ul> Usage <p>from simple_python_boilerplate.engine import process_data</p> Example <p>from simple_python_boilerplate.engine import process_data result = process_data(input_data)</p>"},{"location":"reference/api/#simple_python_boilerplate.engine.VersionInfo","title":"<code>VersionInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Version information structure.</p> Source code in <code>src\\simple_python_boilerplate\\engine.py</code> <pre><code>class VersionInfo(TypedDict):\n    \"\"\"Version information structure.\"\"\"\n\n    package_version: str\n    python_version: str\n    python_full: str\n    platform: str\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.engine.DiagnosticInfo","title":"<code>DiagnosticInfo</code>","text":"<p>               Bases: <code>TypedDict</code></p> <p>Environment diagnostic information structure.</p> Source code in <code>src\\simple_python_boilerplate\\engine.py</code> <pre><code>class DiagnosticInfo(TypedDict):\n    \"\"\"Environment diagnostic information structure.\"\"\"\n\n    version: VersionInfo\n    executable: str\n    prefix: str\n    in_virtual_env: bool\n    tools: dict[str, str | None]\n    config_files: dict[str, bool]\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.engine.get_version_info","title":"<code>get_version_info()</code>","text":"<p>Get version information for the package and environment.</p> <p>Returns:</p> Type Description <code>VersionInfo</code> <p>Dictionary with version details.</p> Source code in <code>src\\simple_python_boilerplate\\engine.py</code> <pre><code>def get_version_info() -&gt; VersionInfo:\n    \"\"\"Get version information for the package and environment.\n\n    Returns:\n        Dictionary with version details.\n    \"\"\"\n    try:\n        pkg_version = version(\"simple-python-boilerplate\")\n    except PackageNotFoundError:\n        from simple_python_boilerplate import __version__\n        pkg_version = f\"{__version__} (editable/dev install)\"\n\n    py_ver = sys.version_info\n    return {\n        \"package_version\": pkg_version,\n        \"python_version\": f\"{py_ver.major}.{py_ver.minor}.{py_ver.micro}\",\n        \"python_full\": sys.version,\n        \"platform\": f\"{platform.system()} {platform.release()}\",\n    }\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.engine.diagnose_environment","title":"<code>diagnose_environment()</code>","text":"<p>Diagnose the development environment.</p> <p>Returns:</p> Type Description <code>DiagnosticInfo</code> <p>Dictionary with diagnostic information.</p> Source code in <code>src\\simple_python_boilerplate\\engine.py</code> <pre><code>def diagnose_environment() -&gt; DiagnosticInfo:\n    \"\"\"Diagnose the development environment.\n\n    Returns:\n        Dictionary with diagnostic information.\n    \"\"\"\n    version_info = get_version_info()\n\n    # Check virtual environment\n    in_venv = sys.prefix != sys.base_prefix\n\n    # Check for dev tools\n    tools = [\"pytest\", \"ruff\", \"mypy\", \"pre-commit\"]\n    tool_status = {}\n    for tool in tools:\n        path = shutil.which(tool)\n        tool_status[tool] = path if path else None\n\n    # Check for config files\n    config_files = [\n        \"pyproject.toml\",\n        \".pre-commit-config.yaml\",\n        \".gitignore\",\n        \"requirements.txt\",\n        \"requirements-dev.txt\",\n    ]\n    cwd = Path.cwd()\n    config_status = {cfg: (cwd / cfg).exists() for cfg in config_files}\n\n    return {\n        \"version\": version_info,\n        \"executable\": sys.executable,\n        \"prefix\": sys.prefix,\n        \"in_virtual_env\": in_venv,\n        \"tools\": tool_status,\n        \"config_files\": config_status,\n    }\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.engine.process_data","title":"<code>process_data(data)</code>","text":"<p>Process input data and return result.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Input data to process.</p> required <p>Returns:</p> Type Description <code>str</code> <p>Processed data string.</p> Source code in <code>src\\simple_python_boilerplate\\engine.py</code> <pre><code>def process_data(data: str) -&gt; str:\n    \"\"\"Process input data and return result.\n\n    Args:\n        data: Input data to process.\n\n    Returns:\n        Processed data string.\n    \"\"\"\n    # Example implementation - replace with actual logic\n    return f\"Processed: {data}\"\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.engine.validate_input","title":"<code>validate_input(data)</code>","text":"<p>Validate input data before processing.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>str</code> <p>Input data to validate.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if valid, False otherwise.</p> Source code in <code>src\\simple_python_boilerplate\\engine.py</code> <pre><code>def validate_input(data: str) -&gt; bool:\n    \"\"\"Validate input data before processing.\n\n    Args:\n        data: Input data to validate.\n\n    Returns:\n        True if valid, False otherwise.\n    \"\"\"\n    if not data:\n        return False\n    return True\n</code></pre>"},{"location":"reference/api/#api-layer","title":"API layer","text":"<p>HTTP/REST interface helpers.</p>"},{"location":"reference/api/#simple_python_boilerplate.api","title":"<code>api</code>","text":"<p>HTTP/REST API interface.</p> <p>This module provides the API layer for the application. It handles HTTP requests, routing, serialization, and response formatting. The actual business logic is delegated to the engine module.</p> Typical contents <ul> <li>Route handlers / endpoints</li> <li>Request/response models</li> <li>Authentication middleware</li> <li>API-specific error handling</li> </ul> Usage Note <p>This is a placeholder. Choose your framework (FastAPI, Flask, etc.) and implement accordingly.</p>"},{"location":"reference/api/#simple_python_boilerplate.api--with-fastapi","title":"With FastAPI","text":"<p>from simple_python_boilerplate.api import app uvicorn.run(app, host=\"0.0.0.0\", port=8000)</p>"},{"location":"reference/api/#simple_python_boilerplate.api--with-flask","title":"With Flask","text":"<p>from simple_python_boilerplate.api import app app.run()</p>"},{"location":"reference/api/#simple_python_boilerplate.api.create_app","title":"<code>create_app()</code>","text":"<p>Create and configure the API application.</p> <p>Returns:</p> Type Description <code>Any</code> <p>Configured application instance.</p> Source code in <code>src\\simple_python_boilerplate\\api.py</code> <pre><code>def create_app() -&gt; Any:\n    \"\"\"Create and configure the API application.\n\n    Returns:\n        Configured application instance.\n    \"\"\"\n    # Example with FastAPI (uncomment and install fastapi):\n    # app = FastAPI(\n    #     title=\"simple-python-boilerplate\",\n    #     description=\"API for simple-python-boilerplate\",\n    #     version=\"0.1.0\",\n    # )\n    #\n    # @app.get(\"/health\")\n    # def health_check():\n    #     return {\"status\": \"ok\"}\n    #\n    # @app.post(\"/process\")\n    # def process(data: str):\n    #     from simple_python_boilerplate.engine import process_data\n    #     return {\"result\": process_data(data)}\n    #\n    # return app\n\n    # Placeholder - replace with actual implementation\n    raise NotImplementedError(\"API not configured. Choose a framework and implement.\")\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.api.health_check","title":"<code>health_check()</code>","text":"<p>Check API health status.</p> <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Health status dictionary.</p> Source code in <code>src\\simple_python_boilerplate\\api.py</code> <pre><code>def health_check() -&gt; dict[str, str]:\n    \"\"\"Check API health status.\n\n    Returns:\n        Health status dictionary.\n    \"\"\"\n    return {\"status\": \"ok\"}\n</code></pre>"},{"location":"reference/api/#cli","title":"CLI","text":"<p>Command-line interface definitions and argument parsing.</p>"},{"location":"reference/api/#simple_python_boilerplate.cli","title":"<code>cli</code>","text":"<p>Command-line interface definitions and argument parsing.</p> <p>This module handles CLI argument parsing and command definitions. It provides the user-facing command structure while delegating actual work to the engine module. Entry points in main.py call into this module.</p> Typical contents <ul> <li>Argument parser setup</li> <li>Command definitions</li> <li>Input validation for CLI</li> <li>Output formatting for terminal</li> </ul> Usage Note <p>For simple CLIs, argparse is sufficient. For complex CLIs, consider click, typer, or rich-click.</p>"},{"location":"reference/api/#simple_python_boilerplate.cli--as-entry-point-configured-in-pyprojecttoml","title":"As entry point (configured in pyproject.toml)","text":"<p>$ my-command --help</p>"},{"location":"reference/api/#simple_python_boilerplate.cli--programmatic","title":"Programmatic","text":"<p>from simple_python_boilerplate.cli import parse_args, run args = parse_args() run(args)</p>"},{"location":"reference/api/#simple_python_boilerplate.cli.create_parser","title":"<code>create_parser()</code>","text":"<p>Create and configure the argument parser.</p> <p>Returns:</p> Type Description <code>ArgumentParser</code> <p>Configured ArgumentParser instance.</p> Source code in <code>src\\simple_python_boilerplate\\cli.py</code> <pre><code>def create_parser() -&gt; argparse.ArgumentParser:\n    \"\"\"Create and configure the argument parser.\n\n    Returns:\n        Configured ArgumentParser instance.\n    \"\"\"\n    parser = argparse.ArgumentParser(\n        prog=\"simple-python-boilerplate\",\n        description=\"A minimal Python boilerplate project.\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n    )\n\n    parser.add_argument(\n        \"-v\", \"--version\",\n        action=\"store_true\",\n        help=\"Show version information and exit\",\n    )\n\n    parser.add_argument(\n        \"--verbose\",\n        action=\"store_true\",\n        help=\"Enable verbose output\",\n    )\n\n    # Add subcommands\n    subparsers = parser.add_subparsers(\n        dest=\"command\", help=\"Available commands\"\n    )\n\n    # Process command\n    process_parser = subparsers.add_parser(\n        \"process\", help=\"Process input data\"\n    )\n    process_parser.add_argument(\"input\", help=\"Input data to process\")\n    process_parser.add_argument(\n        \"-o\", \"--output\",\n        help=\"Output file (default: stdout)\",\n    )\n\n    # Doctor command\n    subparsers.add_parser(\"doctor\", help=\"Diagnose environment issues\")\n\n    return parser\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.cli.parse_args","title":"<code>parse_args(args=None)</code>","text":"<p>Parse command-line arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Sequence[str] | None</code> <p>Arguments to parse. If None, uses sys.argv.</p> <code>None</code> <p>Returns:</p> Type Description <code>Namespace</code> <p>Parsed arguments namespace.</p> Source code in <code>src\\simple_python_boilerplate\\cli.py</code> <pre><code>def parse_args(args: Sequence[str] | None = None) -&gt; argparse.Namespace:\n    \"\"\"Parse command-line arguments.\n\n    Args:\n        args: Arguments to parse. If None, uses sys.argv.\n\n    Returns:\n        Parsed arguments namespace.\n    \"\"\"\n    parser = create_parser()\n    return parser.parse_args(args)\n</code></pre>"},{"location":"reference/api/#simple_python_boilerplate.cli.run","title":"<code>run(args)</code>","text":"<p>Execute the CLI based on parsed arguments.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Namespace</code> <p>Parsed command-line arguments.</p> required <p>Returns:</p> Type Description <code>int</code> <p>Exit code (0 for success, non-zero for errors).</p> Source code in <code>src\\simple_python_boilerplate\\cli.py</code> <pre><code>def run(args: argparse.Namespace) -&gt; int:\n    \"\"\"Execute the CLI based on parsed arguments.\n\n    Args:\n        args: Parsed command-line arguments.\n\n    Returns:\n        Exit code (0 for success, non-zero for errors).\n    \"\"\"\n    if args.version:\n        from simple_python_boilerplate.engine import get_version_info\n        info = get_version_info()\n        print(f\"simple-python-boilerplate {info['package_version']}\")\n        print(f\"Python {info['python_full']}\")\n        return 0\n\n    if args.command == \"doctor\":\n        from simple_python_boilerplate.main import doctor\n        doctor()  # doctor() in main.py handles formatting\n        return 0\n\n    if args.command == \"process\":\n        from simple_python_boilerplate.engine import (\n            process_data,\n            validate_input,\n        )\n\n        if not validate_input(args.input):\n            print(\"Error: Invalid input\")\n            return 1\n\n        result = process_data(args.input)\n\n        if args.output:\n            with open(args.output, \"w\") as f:\n                f.write(result)\n            if args.verbose:\n                print(f\"Output written to {args.output}\")\n        else:\n            print(result)\n\n        return 0\n\n    # No command specified - show help\n    create_parser().print_help()\n    return 0\n</code></pre>"}]}