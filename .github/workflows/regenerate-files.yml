# ──────────────────────────────────────────────────────────────
# Regenerate Files Workflow
# ──────────────────────────────────────────────────────────────
# Regenerates derived files from their source of truth and opens
# a PR if anything changed. Currently regenerates:
#
#   - requirements.txt       (from pyproject.toml [project].dependencies)
#   - requirements-dev.txt   (from pyproject.toml [project.optional-dependencies])
#
# pyproject.toml is the single source of truth for all
# dependencies. These requirements files are convenience copies
# for users who prefer plain pip. Over time they drift — this
# workflow keeps them in sync automatically.
#
# Triggers:
#   - Weekly schedule (Monday 10:00 UTC)
#   - Manual dispatch via the GitHub Actions UI
#
# TODO (template users):
#   1. Enable the repository guard (pick ONE):
#        Option A – Replace 'YOURNAME/YOURREPO' below with
#                   your actual repo slug (e.g. 'myorg/myproject').
#        Option B – Set a repository variable (no YAML edits needed):
#                     vars.ENABLE_REGENERATE_FILES = 'true'
#                   (Settings → Secrets and variables → Actions → Variables)
#   2. (Optional) Add more regeneration steps below if your project
#      has other derived files that should stay in sync.
# ──────────────────────────────────────────────────────────────

name: Regenerate files

on:
  schedule:
    - cron: "0 10 * * 1" # Every Monday at 10:00 UTC
  workflow_dispatch:

permissions:
  contents: write
  pull-requests: write

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

jobs:
  regenerate:
    name: Regenerate derived files

    # ── Repository guard ──────────────────────────────────────
    if: >-
      ${{
        github.repository == 'YOURNAME/YOURREPO'
        || vars.ENABLE_WORKFLOWS == 'true'
        || vars.ENABLE_REGENERATE_FILES == 'true'
      }}
    runs-on: ubuntu-latest
    timeout-minutes: 10

    steps:
      - name: Checkout repository
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          persist-credentials: false

      - name: Set up Python
        uses: actions/setup-python@a309ff8b426b58ec0e2a45f0f869d46889d02405 # v6.2.0
        with:
          python-version: "3.12"

      - name: Install hatch
        run: python -m pip install --upgrade pip hatch

      - name: Install project in editable mode
        run: python -m pip install -e ".[dev]"

      # ── Regenerate requirements.txt ─────────────────────────
      # Reads [project].dependencies from pyproject.toml and
      # writes them into the convenience requirements.txt file.
      - name: Regenerate requirements.txt
        run: |
          python -c "
          import tomllib
          from pathlib import Path

          pyproject = tomllib.loads(Path('pyproject.toml').read_text())
          deps = pyproject.get('project', {}).get('dependencies', [])

          header = '''# Optional: this repo uses pyproject.toml as the source of truth.
          # Runtime dependencies for simple-python-boilerplate
          # Install with: python -m pip install -r requirements.txt
          #
          # NOTE: This file mirrors the [project].dependencies in pyproject.toml
          # For editable install with all deps, prefer: python -m pip install -e .
          # This file is primarily for users who prefer using pip and requirements files.
          #
          # Auto-generated by regenerate-files.yml — do not edit manually.
          '''
          import textwrap
          header = textwrap.dedent(header)

          lines = [header]
          if deps:
              for dep in deps:
                  lines.append(dep)
              lines.append('')
          else:
              lines.append('# Add your runtime dependencies below:')
              lines.append('# requests>=2.28')
              lines.append('# click>=8.0')
              lines.append('')

          Path('requirements.txt').write_text('\n'.join(lines))
          print('Regenerated requirements.txt')
          "

      # ── Regenerate requirements-dev.txt ─────────────────────
      # Reads [project.optional-dependencies] from pyproject.toml
      # and writes a human-readable requirements-dev.txt.
      - name: Regenerate requirements-dev.txt
        run: |
          python -c "
          import tomllib
          from pathlib import Path

          pyproject = tomllib.loads(Path('pyproject.toml').read_text())
          opt_deps = pyproject.get('project', {}).get('optional-dependencies', {})

          header = '''# Optional: this repo uses pyproject.toml as the source of truth.
          # Development dependencies for simple-python-boilerplate
          # Install with: python -m pip install -r requirements-dev.txt
          #
          # NOTE: This file mirrors [project.optional-dependencies] in pyproject.toml
          # For editable install with dev deps, prefer: python -m pip install -e \".[dev]\"
          # This file is primarily for users who prefer using pip and requirements files.
          #
          # Auto-generated by regenerate-files.yml — do not edit manually.
          '''
          import textwrap
          header = textwrap.dedent(header)

          lines = [header]

          # Include runtime dependencies
          lines.append('# Include runtime dependencies')
          lines.append('-r requirements.txt')
          lines.append('')

          # Map group names to friendly section headers
          group_labels = {
              'test': 'Testing',
              'dev': 'Development (includes test deps)',
              'extras': 'Optional helpful tools',
              'docs': 'Documentation',
          }

          # Skip groups that just reference other groups (like dev = [project[test]])
          skip_self_refs = {'simple-python-boilerplate[test]', 'simple-python-boilerplate[dev]'}

          for group in ['test', 'dev', 'extras', 'docs']:
              if group not in opt_deps:
                  continue
              deps = [d for d in opt_deps[group] if d.lower() not in {s.lower() for s in skip_self_refs}]
              if not deps:
                  continue
              label = group_labels.get(group, group.title())
              lines.append(f'# {label}')
              for dep in deps:
                  lines.append(dep)
              lines.append('')

          Path('requirements-dev.txt').write_text('\n'.join(lines))
          print('Regenerated requirements-dev.txt')
          "

      # ── Add version comments ────────────────────────────────
      # Runs dep_versions.py update-comments to annotate each dep
      # line with its package summary and installed version, just
      # like the hand-maintained files had.  Requires the project
      # to be installed (done above) so metadata is available.
      - name: Add version comments to requirements files
        run: python scripts/dep_versions.py update-comments

      # ── Check for changes and create PR ─────────────────────
      - name: Check for changes
        id: diff
        run: |
          git diff --exit-code requirements.txt requirements-dev.txt \
            && echo "changed=false" >> "$GITHUB_OUTPUT" \
            || echo "changed=true" >> "$GITHUB_OUTPUT"

      - name: Create pull request
        if: steps.diff.outputs.changed == 'true'
        uses: peter-evans/create-pull-request@c0f553fe549906ede9cf27b5156039d195d2ece0 # v8.1.0
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          branch: chore/regenerate-files
          commit-message: "chore: regenerate requirements files from pyproject.toml"
          title: "chore: regenerate requirements files from pyproject.toml"
          body: |
            Automated regeneration of derived files from `pyproject.toml`.

            **Files regenerated:**
            - `requirements.txt` — from `[project].dependencies`
            - `requirements-dev.txt` — from `[project.optional-dependencies]`

            Review the diff to confirm the changes look correct, then merge.
          labels: dependencies
          delete-branch: true
