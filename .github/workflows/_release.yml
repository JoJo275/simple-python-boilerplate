# ──────────────────────────────────────────────────────────────
# Release Workflow
# ──────────────────────────────────────────────────────────────
# Builds Python distribution artifacts (sdist + wheel) and
# optionally publishes them to PyPI.
#
# Triggers:
#   - Pushing a semver tag like v1.2.3
#   - Manual dispatch via the GitHub Actions UI
#
# TODO (template users):
#   1. Rename this file from _release.yml → release.yml to put
#      it into an active state (ready for use). The underscore
#      prefix keeps it inactive until you are ready to enable it.
#   2. Enable the repository guard (pick ONE):
#        Option A – Replace 'YOURNAME/YOURTEMPLATE' below with
#                   your actual repo slug (e.g. 'myorg/myproject').
#        Option B – Set two repository-level variables (no YAML
#                   edits needed):
#                     vars.CANONICAL_REPO = 'myorg/myproject'
#                     vars.ENABLE_RELEASE = 'true'
#                   (Settings → Secrets and variables → Actions → Variables)
#   3. Add a PUBLISH_TOKEN secret for PyPI publishing
#      (Settings → Secrets and variables → Actions → Secrets).
# ──────────────────────────────────────────────────────────────

name: Release

on:
  # Trigger on version tags (e.g. v1.0.0, v2.3.1)
  push:
    tags:
      - "v*.*.*"

  # Allow running this workflow manually from the Actions tab
  workflow_dispatch:

jobs:
  # ── Job 1: Build ───────────────────────────────────────────
  # Produces sdist (.tar.gz) and wheel (.whl) in dist/,
  # then uploads them as a workflow artifact for the publish job.
  build:
    name: Build distribution

    # ── Repository guard ──────────────────────────────────────
    # Prevents this workflow from running on forks or clones
    # that haven't opted in. Two ways to satisfy this condition:
    #
    #   Option A  – Edit the hardcoded slug below to match your
    #               own repo (e.g. 'myorg/myproject').
    #
    #   Option B  – Set two repository-level variables (no YAML
    #               edits needed):
    #                 vars.CANONICAL_REPO  = 'myorg/myproject'
    #                 vars.ENABLE_RELEASE  = 'true'
    #               (Settings → Secrets and variables → Actions → Variables)
    if: >-
      ${{
        github.repository == 'YOURNAME/YOURTEMPLATE'
        || (
          github.repository == vars.CANONICAL_REPO
          && vars.ENABLE_RELEASE == 'true'
        )
      }}
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v6

      - name: Set up Python
        uses: actions/setup-python@v6
        with:
          python-version: "3.12"

      # Install pip + build front-end (PEP 517)
      - name: Install build tools
        run: python -m pip install --upgrade pip build

      # Produces dist/*.tar.gz (sdist) and dist/*.whl (wheel)
      - name: Build package
        run: python -m build

      # Persist the built artifacts so the publish job can use them
      - name: Upload distribution artifacts
        uses: actions/upload-artifact@v6
        with:
          name: dist
          path: dist/

  # ── Job 2: Publish ─────────────────────────────────────────
  # Downloads the artifacts produced by the build job and
  # publishes them to PyPI — but only if PUBLISH_TOKEN is set.
  publish:
    name: Publish to PyPI
    needs: build               # Wait for the build job to succeed
    runs-on: ubuntu-latest
    environment: release       # Uses the "release" deployment environment (optional approvals, etc.)
    permissions:
      id-token: write          # Needed for PyPI trusted publishing (OIDC)

    # ── Secret → env mapping ─────────────────────────────────
    # GitHub Actions does not allow secrets in `if:` expressions
    # directly, so we copy the secret into an env var first.
    # Steps below can then test `env.PUBLISH_TOKEN` in their
    # own `if:` conditions.
    env:
      PUBLISH_TOKEN: ${{ secrets.PUBLISH_TOKEN }}

    steps:
      # Retrieve the dist/ artifacts uploaded by the build job
      - name: Download distribution artifacts
        uses: actions/download-artifact@v6
        with:
          name: dist
          path: dist/

      # Publish to PyPI only when the secret exists
      - name: Publish to PyPI
        if: ${{ env.PUBLISH_TOKEN != '' }}
        uses: pypa/gh-action-pypi-publish@release/v1

      # Fail with a helpful message when the secret is missing.
      # If you want this step to skip without failing the workflow,
      # replace "exit 1" with "exit 0".
      - name: Missing token instructions
        if: ${{ env.PUBLISH_TOKEN == '' }}
        run: |
          echo "Missing secret: PUBLISH_TOKEN"
          echo "Add it in Settings → Secrets and variables → Actions → Secrets"
          exit 1

  # ── Job 3: GitHub Release ──────────────────────────────────
  # Creates a GitHub Release on the Releases page and attaches
  # the built distribution artifacts (sdist + wheel).
  # Runs after build succeeds but independently of publish —
  # so a GitHub Release is created even if PyPI publishing is
  # not configured.
  github-release:
    name: Create GitHub Release
    needs: build               # Only needs the build artifacts, not PyPI publish
    runs-on: ubuntu-latest
    permissions:
      contents: write          # Required to create releases and upload assets

    steps:
      # Retrieve the dist/ artifacts uploaded by the build job
      - name: Download distribution artifacts
        uses: actions/download-artifact@v6
        with:
          name: dist
          path: dist/

      # Create a GitHub Release using the tag name and attach
      # all files in dist/ (*.tar.gz, *.whl) as release assets.
      # --generate-notes auto-generates release notes from commits
      # and PRs since the last tag.
      - name: Create release with artifacts
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh release create "${{ github.ref_name }}" \
            --title "${{ github.ref_name }}" \
            --generate-notes \
            dist/*
